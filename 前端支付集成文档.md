# 益禾堂奶茶点餐系统 - 前端支付集成文档

## 1. 概述

本文档旨在指导前端开发者如何集成支付功能，包括微信支付、支付宝支付的调用流程、API接口说明以及相关注意事项。通过本文档的指导，前端开发者可以快速实现与后端支付服务的对接，为用户提供流畅的支付体验。

## 2. 技术栈

- **前端框架**：Vue 3 + TypeScript
- **HTTP客户端**：Axios
- **UI组件库**：Element Plus
- **支付SDK**：
  - 微信支付：微信小程序支付SDK / 微信JSAPI支付SDK
  - 支付宝支付：支付宝JSAPI支付SDK

## 3. 支付流程

### 3.1 通用支付流程

1. **创建订单**：用户选择商品后，前端向后端发送创建订单请求，获取订单号
2. **发起支付**：前端携带订单号调用后端支付接口，获取支付参数
3. **调起支付**：使用获取到的支付参数调用相应支付SDK的支付方法
4. **处理支付结果**：
   - 支付成功：跳转到支付成功页面，更新订单状态
   - 支付失败：显示失败原因，引导用户重新支付
   - 支付取消：返回购物车或订单页面
5. **查询支付状态**：为确保支付结果的准确性，前端应调用后端接口查询最终支付状态

### 3.2 微信支付流程

1. **获取支付参数**：调用后端 `/api/payment/create` 接口，获取微信支付参数
2. **调起微信支付**：使用 `wx.requestPayment()` 方法调起微信支付
3. **处理支付回调**：在支付SDK的回调函数中处理支付结果

### 3.3 支付宝支付流程

1. **获取支付参数**：调用后端 `/api/payment/create` 接口，获取支付宝支付参数
2. **调起支付宝支付**：使用 `alipay.trade.create()` 方法调起支付宝支付
3. **处理支付回调**：在支付SDK的回调函数中处理支付结果

## 4. API接口说明

### 4.1 创建支付单

- **接口路径**：`POST /api/payment/create`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | orderNo | String | 是 | 订单号 |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": {
      "paymentNo": "PAY20260130123456789",
      "orderNo": "ORDER20260130123456789",
      "amount": 25.5,
      "paymentMethod": 1,
      "appId": "wx70e7b0411521d834",
      "timeStamp": "1769650000",
      "nonceStr": "mock_nonce_1769650000000",
      "package": "prepay_id=mock_prepay_PAY20260130123456789",
      "signType": "RSA",
      "paySign": "mock_sign_PAY20260130123456789",
      "notifyUrl": "http://your-domain.com/api/payment/callback"
    }
  }
  ```

### 4.2 查询支付状态

- **接口路径**：`GET /api/payment/status/{orderNo}`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | orderNo | String | 是 | 订单号（路径参数） |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": {
      "id": 1,
      "orderNo": "ORDER20260130123456789",
      "paymentNo": "PAY20260130123456789",
      "userId": 1,
      "amount": 25.5,
      "paymentMethod": 1,
      "paymentStatus": 1,
      "transactionId": "MOCK_1769650000000",
      "createTime": "2026-01-30T12:00:00",
      "payTime": "2026-01-30T12:01:00",
      "callbackTime": "2026-01-30T12:01:00"
    }
  }
  ```

### 4.3 申请退款

- **接口路径**：`POST /api/payment/refund/apply`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | orderNo | String | 是 | 订单号 |
  | refundAmount | Number | 是 | 退款金额 |
  | refundReason | String | 是 | 退款原因 |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": {
      "refundNo": "REFUND_1769650000000123",
      "orderNo": "ORDER20260130123456789",
      "refundAmount": 25.5,
      "refundTime": "2026-01-30T12:05:00",
      "status": "SUCCESS"
    }
  }
  ```

### 4.4 查询退款状态

- **接口路径**：`GET /api/payment/refund/status/{refundNo}`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | refundNo | String | 是 | 退款单号（路径参数） |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": {
      "refundNo": "REFUND_1769650000000123",
      "orderNo": "ORDER20260130123456789",
      "refundAmount": 25.5,
      "refundReason": "商品质量问题",
      "refundTime": "2026-01-30T12:05:00",
      "status": "SUCCESS"
    }
  }
  ```

### 4.5 查询支付记录列表

- **接口路径**：`GET /api/payment/records`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | page | Number | 否 | 页码，默认1 |
  | pageSize | Number | 否 | 每页大小，默认10 |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": [
      {
        "id": 1,
        "orderNo": "ORDER20260130123456789",
        "paymentNo": "PAY20260130123456789",
        "userId": 1,
        "amount": 25.5,
        "paymentMethod": 1,
        "paymentStatus": 1,
        "transactionId": "MOCK_1769650000000",
        "createTime": "2026-01-30T12:00:00",
        "payTime": "2026-01-30T12:01:00"
      }
    ]
  }
  ```

### 4.6 查询支付记录详情

- **接口路径**：`GET /api/payment/detail/{paymentNo}`
- **请求参数**：
  | 参数名 | 类型 | 必填 | 描述 |
  | --- | --- | --- | --- |
  | paymentNo | String | 是 | 支付单号（路径参数） |

- **响应数据**：
  ```json
  {
    "code": 200,
    "message": "成功",
    "data": {
      "id": 1,
      "orderNo": "ORDER20260130123456789",
      "paymentNo": "PAY20260130123456789",
      "userId": 1,
      "amount": 25.5,
      "paymentMethod": 1,
      "paymentStatus": 1,
      "transactionId": "MOCK_1769650000000",
      "createTime": "2026-01-30T12:00:00",
      "payTime": "2026-01-30T12:01:00",
      "callbackTime": "2026-01-30T12:01:00"
    }
  }
  ```

## 5. 代码示例

### 5.1 发起支付

```typescript
// payment.service.ts
import axios from 'axios';

// 支付方式枚举
export enum PaymentMethod {
  WECHAT = 1,
  ALIPAY = 2,
  CASH = 3
}

// 支付参数接口
export interface PaymentParams {
  paymentNo: string;
  orderNo: string;
  amount: number;
  paymentMethod: PaymentMethod;
  // 微信支付参数
  appId?: string;
  timeStamp?: string;
  nonceStr?: string;
  package?: string;
  signType?: string;
  paySign?: string;
  notifyUrl?: string;
  // 支付宝支付参数
  outTradeNo?: string;
  subject?: string;
  totalAmount?: string;
  productCode?: string;
  returnUrl?: string;
}

// 创建支付单
export async function createPayment(orderNo: string): Promise<PaymentParams> {
  const response = await axios.post('/api/payment/create', {
    orderNo
  });
  return response.data.data;
}

// 查询支付状态
export async function getPaymentStatus(orderNo: string): Promise<any> {
  const response = await axios.get(`/api/payment/status/${orderNo}`);
  return response.data.data;
}

// 申请退款
export async function applyRefund(orderNo: string, refundAmount: number, refundReason: string): Promise<any> {
  const response = await axios.post('/api/payment/refund/apply', {
    orderNo,
    refundAmount,
    refundReason
  });
  return response.data.data;
}
```

### 5.2 微信支付调用

```typescript
// 微信小程序支付
export async function wechatPay(orderNo: string): Promise<boolean> {
  try {
    // 获取支付参数
    const paymentParams = await createPayment(orderNo);
    
    // 调起微信支付
    return new Promise((resolve, reject) => {
      wx.requestPayment({
        timeStamp: paymentParams.timeStamp!,
        nonceStr: paymentParams.nonceStr!,
        package: paymentParams.package!,
        signType: paymentParams.signType!,
        paySign: paymentParams.paySign!,
        success: (res) => {
          console.log('微信支付成功:', res);
          resolve(true);
        },
        fail: (err) => {
          console.error('微信支付失败:', err);
          reject(err);
        },
        complete: () => {
          // 无论成功失败都会执行
        }
      });
    });
  } catch (error) {
    console.error('发起微信支付失败:', error);
    throw error;
  }
}
```

### 5.3 支付宝支付调用

```typescript
// 支付宝JSAPI支付
export async function alipayPay(orderNo: string): Promise<boolean> {
  try {
    // 获取支付参数
    const paymentParams = await createPayment(orderNo);
    
    // 调起支付宝支付
    return new Promise((resolve, reject) => {
      // 这里需要引入支付宝SDK
      // @ts-ignore
      if (window.alipay) {
        // @ts-ignore
        window.alipay.trade.create({
          appId: paymentParams.appId!,
          outTradeNo: paymentParams.outTradeNo!,
          subject: paymentParams.subject!,
          totalAmount: paymentParams.totalAmount!,
          productCode: paymentParams.productCode!,
          returnUrl: paymentParams.returnUrl!,
          notifyUrl: paymentParams.notifyUrl!,
          success: (res: any) => {
            console.log('支付宝支付成功:', res);
            resolve(true);
          },
          fail: (err: any) => {
            console.error('支付宝支付失败:', err);
            reject(err);
          }
        });
      } else {
        reject(new Error('支付宝SDK未加载'));
      }
    });
  } catch (error) {
    console.error('发起支付宝支付失败:', error);
    throw error;
  }
}
```

### 5.4 支付结果处理

```vue
<template>
  <el-dialog
    v-model="visible"
    title="支付确认"
    width="30%"
    :close-on-click-modal="false"
  >
    <div class="payment-content">
      <p>订单号: {{ orderNo }}</p>
      <p>支付金额: ¥{{ amount.toFixed(2) }}</p>
      <div class="payment-methods">
        <el-radio-group v-model="selectedMethod">
          <el-radio :label="PaymentMethod.WECHAT">微信支付</el-radio>
          <el-radio :label="PaymentMethod.ALIPAY">支付宝支付</el-radio>
        </el-radio-group>
      </div>
    </div>
    <template #footer>
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="handlePay" :loading="loading">
        {{ loading ? '处理中...' : '确认支付' }}
      </el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, defineProps, defineEmits } from 'vue';
import { ElMessage } from 'element-plus';
import { wechatPay, alipayPay, getPaymentStatus, PaymentMethod } from '@/services/payment.service';

const props = defineProps<{
  visible: boolean;
  orderNo: string;
  amount: number;
}>();

const emit = defineEmits<{
  (e: 'update:visible', value: boolean): void;
  (e: 'paySuccess'): void;
  (e: 'payFail', error: string): void;
}>();

const visible = ref(props.visible);
const loading = ref(false);
const selectedMethod = ref(PaymentMethod.WECHAT);

// 监听visible变化
watch(() => props.visible, (newVal) => {
  visible.value = newVal;
});

// 处理支付
async function handlePay() {
  loading.value = true;
  try {
    let paySuccess = false;
    
    // 根据选择的支付方式发起支付
    if (selectedMethod.value === PaymentMethod.WECHAT) {
      paySuccess = await wechatPay(props.orderNo);
    } else if (selectedMethod.value === PaymentMethod.ALIPAY) {
      paySuccess = await alipayPay(props.orderNo);
    }
    
    // 查询最终支付状态
    const paymentStatus = await getPaymentStatus(props.orderNo);
    
    if (paymentStatus.paymentStatus === 1) { // 支付成功
      ElMessage.success('支付成功！');
      emit('paySuccess');
      visible.value = false;
    } else {
      ElMessage.error('支付失败，请稍后重试');
      emit('payFail', '支付未完成');
    }
  } catch (error: any) {
    console.error('支付失败:', error);
    ElMessage.error(error.message || '支付失败，请稍后重试');
    emit('payFail', error.message || '支付失败');
  } finally {
    loading.value = false;
  }
}
</script>

<style scoped>
.payment-content {
  padding: 20px 0;
}

.payment-methods {
  margin-top: 20px;
}

.el-radio {
  display: block;
  margin-bottom: 10px;
}
</style>
```

## 6. 注意事项

### 6.1 安全性

1. **数据加密**：确保支付相关参数的传输使用HTTPS加密
2. **签名验证**：前端不需要验证支付签名，签名验证由后端负责
3. **防重放攻击**：后端已实现幂等性处理，前端无需额外处理
4. **参数校验**：前端应验证用户输入，确保支付金额等参数的合法性

### 6.2 兼容性

1. **微信支付**：
   - 微信小程序：确保在小程序环境中调用 `wx.requestPayment()`
   - H5页面：使用微信JSAPI支付，需要在微信浏览器中打开
2. **支付宝支付**：
   - 确保支付宝SDK已正确加载
   - 处理不同浏览器的兼容性问题

### 6.3 用户体验

1. **加载状态**：在支付过程中显示加载动画，避免用户重复操作
2. **错误处理**：对支付过程中可能出现的错误进行友好提示
3. **超时处理**：设置合理的支付超时时间，超时后引导用户重新支付
4. **订单状态同步**：支付完成后及时更新订单状态，确保用户看到最新信息

### 6.4 调试技巧

1. **使用模拟支付**：在开发环境中，可以使用后端提供的 `/api/payment/mock/success` 接口模拟支付成功
2. **查看支付日志**：通过浏览器控制台查看支付相关的日志信息
3. **网络请求监控**：使用浏览器的网络面板监控支付相关的API调用
4. **支付状态查询**：遇到支付异常时，调用 `/api/payment/status/{orderNo}` 接口查询最终支付状态

## 7. 常见问题

### 7.1 支付失败

- **原因**：
  - 网络问题：网络连接不稳定
  - 支付账号问题：余额不足、账号异常
  - 支付参数错误：后端返回的支付参数有误
  - 支付SDK调用失败：SDK未正确初始化或调用方式错误

- **解决方案**：
  - 检查网络连接
  - 确认支付账号状态
  - 核对订单信息和支付参数
  - 检查支付SDK的初始化和调用方式
  - 调用后端查询接口获取最终支付状态

### 7.2 支付成功但订单状态未更新

- **原因**：
  - 支付回调未收到
  - 后端处理回调失败
  - 前端未及时查询支付状态

- **解决方案**：
  - 调用后端 `/api/payment/status/{orderNo}` 接口查询支付状态
  - 如确认支付成功，可手动更新订单状态
  - 联系后端开发人员检查支付回调处理逻辑

### 7.3 重复支付

- **原因**：
  - 用户多次点击支付按钮
  - 支付超时后用户重新发起支付

- **解决方案**：
  - 前端添加防重复点击处理
  - 后端实现幂等性校验，同一订单只能有一个待支付的支付单
  - 支付过程中显示明确的加载状态，避免用户重复操作

## 8. 总结

本文档详细介绍了前端支付集成的相关内容，包括支付流程、API接口、代码示例、注意事项和常见问题。通过本文档的指导，前端开发者可以快速实现与后端支付服务的对接，为用户提供流畅、安全的支付体验。

在实际开发过程中，前端开发者应根据具体的项目需求和技术环境，灵活调整支付集成方案，确保支付功能的稳定性和可靠性。同时，应密切关注支付相关的安全问题，保护用户的支付信息和资金安全。

---

**文档版本**：1.0
**创建日期**：2026-01-30
**更新日期**：2026-01-30